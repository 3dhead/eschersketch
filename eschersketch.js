// Generated by CoffeeScript 1.6.2
(function() {
  var CANVAS_HEIGHT, CANVAS_WIDTH, DRAW_interval, Drawing, INITIAL_SYM, MAX_linewidth, MIN_linewidth, PI, abs, acos, affineset, asin, atan, canvas, changeLineWidth, changeOpacity, circlepaint, clearScreen, cos, ctx, drawLine, floor, initGUI, keyState, lastline, map, max, min, onCanvasMousedown, onDocumentKeydown, onDocumentKeyup, onDocumentMousemove, onDocumentMouseup, pow, renderPoint, root, round, saveImage, setColor, sign, sin, sketch, sqrt, tan, uiState, updateTiling;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  min = Math.min;

  max = Math.max;

  abs = Math.abs;

  sqrt = Math.sqrt;

  floor = Math.floor;

  round = Math.round;

  sin = Math.sin;

  cos = Math.cos;

  tan = Math.tan;

  acos = Math.acos;

  asin = Math.asin;

  atan = Math.atan;

  pow = Math.pow;

  PI = Math.PI;

  sign = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  CANVAS_WIDTH = 1600;

  CANVAS_HEIGHT = 1200;

  DRAW_interval = 0;

  MIN_linewidth = .01;

  MAX_linewidth = 4;

  INITIAL_SYM = "p6m";

  uiState = {
    opacity: 1.0,
    red: 0,
    green: 0,
    blue: 0,
    linewidth: 1.0,
    newline: true,
    canvasActive: false,
    canvasPanning: false,
    canvasCursorM: false,
    canvasXonPan: 0,
    canvasYonPan: 0,
    mouseXonPan: 0,
    mouseYonPan: 0,
    symmetryclass: "p1",
    gridNx: 37,
    gridNy: 31,
    gridX0: 800,
    gridY0: 400,
    gridspacing: 100,
    gridrotation: 0,
    symmetry: "p6m"
  };

  keyState = {
    space: false,
    shift: false,
    ctrl: false
  };

  sketch = {};

  canvas = {};

  ctx = {};

  affineset = [];

  updateTiling = function() {
    return affineset = generateTiling(planarSymmetries[uiState.symmetry], uiState.gridNx, uiState.gridNy, uiState.gridspacing, uiState.gridX0, uiState.gridY0);
  };

  updateTiling();

  map = function(value, istart, istop, ostart, ostop) {
    return ostart + (ostop - ostart) * (value - istart) / (istop - istart);
  };

  Drawing = (function() {
    function Drawing() {
      this.pointCache = new Array();
      this.drawnP = 0;
    }

    Drawing.prototype.addPoint = function(p) {
      this.pointCache.push(p);
      return this.drawnP++;
    };

    Drawing.prototype.render = function() {
      var dp, pc;

      dp = this.drawnP;
      pc = this.pointCache;
      if (dp > 0) {
        return lastline(pc);
      }
    };

    Drawing.prototype.dumpCache = function() {
      return this.pointCache.length = 0;
    };

    return Drawing;

  })();

  lastline = function(pointSet) {
    var Tp1, Tp2, af, p1, p2, ps, _i, _len, _results;

    ps = pointSet.length;
    if (ps > 1 && !uiState.newline) {
      p1 = pointSet[ps - 1];
      p2 = pointSet[ps - 2];
      _results = [];
      for (_i = 0, _len = affineset.length; _i < _len; _i++) {
        af = affineset[_i];
        Tp1 = af.on(p1.x, p1.y);
        Tp2 = af.on(p2.x, p2.y);
        _results.push(ctx.line(Tp2[0], Tp2[1], Tp1[0], Tp1[1]));
      }
      return _results;
    } else {
      if (uiState.newline) {
        return uiState.newline = false;
      }
    }
  };

  circlepaint = function(pointSet) {
    var Tp1, af, p1, ps, _i, _len, _results;

    ps = pointSet.length;
    p1 = pointSet[ps - 1];
    _results = [];
    for (_i = 0, _len = affineset.length; _i < _len; _i++) {
      af = affineset[_i];
      Tp1 = af.on(p1.x, p1.y);
      ctx.beginPath();
      ctx.arc(Tp1[0], Tp1[1], uiState.linewidth, 0, 2 * PI, false);
      ctx.fillStyle = "rgba(" + uiState.red + "," + uiState.green + "," + uiState.blue + "," + uiState.opacity + ")";
      _results.push(ctx.fill());
    }
    return _results;
  };

  renderPoint = function(e) {
    sketch.addPoint({
      x: e.clientX - canvas.offset().left,
      y: e.clientY - canvas.offset().top
    });
    return sketch.render();
  };

  drawLine = function(x1, y1, x2, y2) {
    this.beginPath();
    this.moveTo(x1, y1);
    this.lineTo(x2, y2);
    return this.stroke();
  };

  initGUI = function() {
    var linewidthui, linewidthui_ctx, opacityui;

    sketch = new Drawing();
    canvas = $("#sketch");
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    ctx = canvas[0].getContext("2d");
    ctx.line = drawLine;
    ctx.lineWidth = 0.5;
    ctx.fillStyle = "rgb(255, 255, 255)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    canvas.mousedown(onCanvasMousedown);
    canvas.mouseup(onDocumentMouseup);
    canvas.mousemove(onDocumentMousemove);
    $('body').keyup(onDocumentKeyup);
    $('body').keydown(onDocumentKeydown);
    $(".symsel").click(function() {
      var newsym;

      newsym = $(this).text();
      uiState.symmetry = newsym;
      $(".symsel").removeClass('selected');
      $(this).addClass('selected');
      updateTiling();
      console.log("symmetry ", newsym, affineset.length);
      return canvas.focus();
    });
    $(".symsel:contains(" + uiState.symmetry + ")").addClass('selected');
    ColorPicker($("#color-picker")[0], function(hex, hsv, rgb) {
      console.log(hsv.h, hsv.s, hsv.v);
      console.log(rgb.r, rgb.g, rgb.b);
      setColor(rgb);
      return ctx.strokeStyle = "rgba(" + uiState.red + "," + uiState.green + "," + uiState.blue + "," + uiState.opacity + ")";
    });
    opacityui = $("#ui-opacity");
    opacityui.mousedown(changeOpacity);
    linewidthui = $("#ui-linewidth");
    linewidthui_ctx = linewidthui[0].getContext("2d");
    linewidthui_ctx.beginPath();
    linewidthui_ctx.moveTo(0, 0);
    linewidthui_ctx.lineTo(0, 20);
    linewidthui_ctx.lineTo(200, 0);
    linewidthui_ctx.lineTo(0, 0);
    linewidthui_ctx.closePath();
    linewidthui_ctx.fill();
    linewidthui.mousedown(changeLineWidth);
    $('#clearscreen').click(clearScreen);
    if (window.navigator.userAgent.indexOf('Safari') === -1 || window.navigator.userAgent.indexOf('Chrome') !== -1) {
      return $('#saveimage').click(saveImage);
    } else {
      return $('#saveimage').hide();
    }
  };

  saveImage = function() {
    if (window.navigator.userAgent.indexOf('Safari') === -1 || window.navigator.userAgent.indexOf('Chrome') !== -1) {
      return canvas[0].toBlob(function(blob) {
        return saveAs(blob, "eschersketch.png");
      });
    } else {
      return alert("Saving images clientside will crash some recent versions of Safari. Sorry!");
    }
  };

  clearScreen = function() {
    ctx.fillStyle = "rgb(255, 255, 255)";
    return ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  };

  setColor = function(rgb) {
    uiState.red = rgb.r;
    uiState.green = rgb.g;
    return uiState.blue = rgb.b;
  };

  changeOpacity = function(e) {
    var h, left, top, x, y;

    left = $(this).offset().left;
    top = $(this).offset().top;
    x = e.clientX - left;
    y = e.clientY - top;
    h = $(this).height();
    uiState.opacity = map(y, 0, h, 1.0, 0.0);
    return ctx.strokeStyle = "rgba(" + uiState.red + "," + uiState.green + "," + uiState.blue + "," + uiState.opacity + ")";
  };

  changeLineWidth = function(e) {
    var h, w, x, y;

    x = e.clientX - $(this).offset().left;
    y = e.clientY - $(this).offset().top;
    h = $(this).height();
    w = $(this).width();
    uiState.linewidth = map(x, 0, w, MAX_linewidth, MIN_linewidth);
    return ctx.lineWidth = uiState.linewidth;
  };

  window.initGUI = initGUI;

  onCanvasMousedown = function(e) {
    e.preventDefault();
    if (keyState.space) {
      uiState.canvasPanning = true;
      uiState.mouseXonPan = e.clientX;
      uiState.mouseYonPan = e.clientY;
      uiState.canvasXonPan = canvas.offset().left;
      uiState.canvasYonPan = canvas.offset().top;
      return;
    }
    uiState.newline = true;
    renderPoint(e);
    return uiState.canvasActive = true;
  };

  onDocumentMouseup = function(e) {
    uiState.canvasPanning = false;
    uiState.canvasActive = false;
    return uiState.newline = false;
  };

  onDocumentMousemove = function(e) {
    if (uiState.canvasPanning) {
      canvas[0].style.left = (e.clientX - uiState.mouseXonPan + uiState.canvasXonPan) + "px";
      canvas[0].style.top = (e.clientY - uiState.mouseYonPan + uiState.canvasYonPan) + "px";
    }
    if (keyState.space && uiState.canvasPanning && !uiState.canvasCursorM) {
      canvas.css("cursor", "move");
      uiState.canvasCursorM = true;
    } else if (!uiState.canvasPanning && uiState.canvasCursorM) {
      canvas.css("cursor", "crosshair");
      uiState.canvasCursorM = false;
    }
    if (uiState.canvasActive) {
      if (DRAW_interval <= 0) {
        renderPoint(e);
        DRAW_interval = 1;
      }
      return DRAW_interval--;
    }
  };

  onDocumentKeydown = function(e) {
    switch (e.keyCode) {
      case 32:
        return keyState.space = true;
      case 16:
        return keyState.shift = true;
      case 17:
        return keyState.ctrl = true;
      case 67:
        return keyState.c = true;
      case 8:
      case 46:
        if (keyState.ctrl) {
          sketch.dumpCache();
          return sketch.drawnP = 0;
        }
    }
  };

  onDocumentKeyup = function(e) {
    switch (e.keyCode) {
      case 32:
        return keyState.space = false;
      case 16:
        return keyState.shift = false;
      case 17:
        return keyState.ctrl = false;
      case 67:
        return keyState.c = false;
    }
  };

}).call(this);
