// Generated by CoffeeScript 1.6.2
(function() {
  var CANVAS_HEIGHT, CANVAS_WIDTH, DRAW_interval, Drawing, MAX_linewidth, MIN_linewidth, PI, ScalingAbout2, abs, acos, affineset, asin, atan, canvas, changeLineWidth, changeOpacity, connect, cos, ctx, drawLine, floor, geomseries, initGUI, keyState, lastline, linear_distance, map, max, min, onCanvasMousedown, onDocumentKeydown, onDocumentKeyup, onDocumentMousemove, onDocumentMouseup, pow, renderPoint, root, round, saveDrawing, segmentalset, setColor, sign, sin, sketch, spiralsegmentalset, sqrt, tan, uiState, wacom, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  min = Math.min;

  max = Math.max;

  abs = Math.abs;

  sqrt = Math.sqrt;

  floor = Math.floor;

  round = Math.round;

  sin = Math.sin;

  cos = Math.cos;

  tan = Math.tan;

  acos = Math.acos;

  asin = Math.asin;

  atan = Math.atan;

  pow = Math.pow;

  PI = Math.PI;

  sign = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  CANVAS_WIDTH = 1600;

  CANVAS_HEIGHT = 1200;

  DRAW_interval = 0;

  MIN_linewidth = .01;

  MAX_linewidth = 4;

  wacom = void 0;

  uiState = {
    opacity: 1.0,
    red: 0,
    green: 0,
    blue: 0,
    linewidth: 1.0,
    newline: true,
    canvasActive: false,
    canvasPanning: false,
    canvasCursorM: false,
    canvasXonPan: 0,
    canvasYonPan: 0,
    mouseXonPan: 0,
    mouseYonPan: 0
  };

  keyState = {
    space: false,
    shift: false,
    ctrl: false
  };

  _ref = [{}, {}, {}], sketch = _ref[0], canvas = _ref[1], ctx = _ref[2];

  affineset = rotateRosette(40, 800, 400);

  ScalingAbout2 = function(scale, scaley, px, py) {
    return TranslationTransform(px, py).multiply(ScalingTransform(scale, scaley)).multiply(TranslationTransform(-px, -py));
  };

  segmentalset = function(dx0, segscales) {
    var dx, i, segset, x, _i, _ref1;

    segset = [];
    segset.push(IdentityTransform());
    x = dx0;
    segset.push(TranslationTransform(x, 0).multiply(ScalingAbout2(segscales[0], segscales[0], 800, 400)));
    for (i = _i = 1, _ref1 = segscales.length - 1; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
      dx = segscales[i - 1] * dx0;
      x += dx;
      segset.push(TranslationTransform(x, 0).multiply(ScalingAbout2(segscales[i], segscales[i], 800, 400)));
    }
    return segset;
  };

  spiralsegmentalset = function(dx0, segscales, rot) {
    var dx, i, segset, trot, x, _i, _ref1;

    segset = [];
    segset.push(IdentityTransform());
    trot = 0;
    x = dx0;
    segset.push(TranslationTransform(x, 0).multiply(ScalingAbout2(segscales[0], segscales[0], 800, 400)));
    for (i = _i = 1, _ref1 = segscales.length - 1; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
      dx = segscales[i - 1] * dx0;
      x += dx;
      trot += rot * segscales[i - 1];
      segset.push(RotationAbout(trot, 800, 400).multiply(TranslationTransform(x, 0).multiply(ScalingAbout2(segscales[i], segscales[i], 800, 400))));
    }
    return segset;
  };

  geomseries = function(a, n) {
    var atot, geom, i, _i;

    geom = [];
    atot = a;
    geom.push(atot);
    for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
      atot *= a;
      geom.push(atot);
    }
    return geom;
  };

  linear_distance = function(x2, y2, x1, y1) {
    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  saveDrawing = function() {
    return window.open(canvas.toDataURL("image/png"), "mywindow");
  };

  map = function(value, istart, istop, ostart, ostop) {
    return ostart + (ostop - ostart) * (value - istart) / (istop - istart);
  };

  Drawing = (function() {
    function Drawing() {
      this.pointCache = new Array();
      this.drawnP = 0;
    }

    Drawing.prototype.addPoint = function(p) {
      this.pointCache.push(p);
      return this.drawnP++;
    };

    Drawing.prototype.render = function() {
      var dp, pc;

      dp = this.drawnP;
      pc = this.pointCache;
      if (dp > 0) {
        return lastline(pc);
      }
    };

    Drawing.prototype.dumpCache = function() {
      return this.pointCache.length = 0;
    };

    return Drawing;

  })();

  lastline = function(pointSet) {
    var Tp1, Tp2, af, p1, p2, ps, _i, _len, _results;

    ps = pointSet.length;
    if (ps > 1 && !uiState.newline) {
      p1 = pointSet[ps - 1];
      p2 = pointSet[ps - 2];
      ctx.strokeStyle = "rgba( " + uiState.red + "," + uiState.green + "," + uiState.blue + ",  " + uiState.opacity + "  )";
      _results = [];
      for (_i = 0, _len = affineset.length; _i < _len; _i++) {
        af = affineset[_i];
        Tp1 = af.on(p1.x, p1.y);
        Tp2 = af.on(p2.x, p2.y);
        ctx.lineWidth = p1.linewidth;
        _results.push(ctx.line(Tp2[0], Tp2[1], Tp1[0], Tp1[1]));
      }
      return _results;
    } else {
      if (uiState.newline) {
        return uiState.newline = false;
      }
    }
  };

  connect = function(pointSet) {
    var maxDist, p, p_dist, pnew, ps, totDist, _i, _j, _len, _len1, _results;

    ps = pointSet.length;
    pnew = pointSet[ps - 1];
    if (ps > 1) {
      for (_i = 0, _len = pointSet.length; _i < _len; _i++) {
        p = pointSet[_i];
        p_dist = linear_distance(p.x, p.y, pnew.x, pnew.y);
        p.tempDist = p_dist;
      }
      pointSet.sort(function(a, b) {
        return a.tempDist - b.tempDist;
      });
      ctx.strokeStyle = "rgba( 0,0,0, " + uiOpacity.opacity + " )";
      totDist = 0;
      maxDist = pnew.maxDist;
      _results = [];
      for (_j = 0, _len1 = pointSet.length; _j < _len1; _j++) {
        p = pointSet[_j];
        totDist += drawDist;
        if (totDist < maxDist * 5 && p.tempDist < maxDist) {
          _results.push(ctx.line(pnew.x, pnew.y, p.x, p.y));
        } else {
          break;
        }
      }
      return _results;
    }
  };

  renderPoint = function(e) {
    sketch.addPoint({
      x: e.clientX - canvas.offset().left,
      y: e.clientY - canvas.offset().top,
      linewidth: uiState.linewidth
    });
    return sketch.render();
  };

  drawLine = function(x1, y1, x2, y2) {
    this.beginPath();
    this.moveTo(x1, y1);
    this.lineTo(x2, y2);
    return this.stroke();
  };

  initGUI = function() {
    var clrui, clrui2, clrui2_ctx;

    sketch = new Drawing();
    canvas = $("#sketch");
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    ctx = canvas[0].getContext("2d");
    ctx.line = drawLine;
    ctx.lineWidth = 0.5;
    ctx.fillStyle = "rgb(255, 255, 255)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    canvas.mousedown(onCanvasMousedown);
    canvas.mouseup(onDocumentMouseup);
    canvas.mousemove(onDocumentMousemove);
    $('body').keyup(onDocumentKeyup);
    $('body').keydown(onDocumentKeydown);
    ctx.line(800 - 5, 400, 800 + 5, 400);
    ctx.line(800, 400 - 5, 800, 400 + 5);
    ColorPicker($("#color-picker")[0], function(hex, hsv, rgb) {
      console.log(hsv.h, hsv.s, hsv.v);
      console.log(rgb.r, rgb.g, rgb.b);
      return setColor(rgb);
    });
    $(".symsel").click(function() {
      var newsym;

      newsym = $(this).text();
      $(".symsel").removeClass('selected');
      $(this).addClass('selected');
      affineset = generateTiling(planarSymmetries[newsym], 37, 31, 100, 800, 400);
      console.log("symmetry ", newsym, affineset.length);
      return canvas.focus();
    });
    $("#symselect").change(function() {
      var newsym;

      newsym = $(this).val();
      affineset = generateTiling(planarSymmetries[newsym], 37, 31, 100, 800, 400);
      console.log("symmetry ", newsym, affineset.length);
      return canvas.focus();
    });
    clrui = $("#ui-opacity");
    clrui.mousedown(changeOpacity);
    clrui2 = $("#ui-color2");
    clrui2_ctx = clrui2[0].getContext("2d");
    clrui2_ctx.beginPath();
    clrui2_ctx.moveTo(0, 0);
    clrui2_ctx.lineTo(20, 0);
    clrui2_ctx.lineTo(0, 100);
    clrui2_ctx.lineTo(0, 0);
    clrui2_ctx.closePath();
    clrui2_ctx.fill();
    return clrui2.mousedown(changeLineWidth);
  };

  setColor = function(rgb) {
    uiState.red = rgb.r;
    uiState.green = rgb.g;
    uiState.blue = rgb.b;
    return console.log("RGB: ", uiState.red, uiState.green, uiState.blue);
  };

  changeOpacity = function(e) {
    var h, left, top, x, y;

    left = $(this).offset().left;
    top = $(this).offset().top;
    x = e.clientX - left;
    y = e.clientY - top;
    h = $(this).height();
    uiState.opacity = map(y, 0, h, 1.0, 0.0);
    return console.log("changeopacity ", x, y, h, uiState.opacity);
  };

  changeLineWidth = function(e) {
    var h, x, y;

    x = e.clientX - $(this).offset().left;
    y = e.clientY - $(this).offset().top;
    h = $(this).height();
    uiState.linewidth = map(y, 0, h, MAX_linewidth, MIN_linewidth);
    return console.log("changelinewidth ", x, y, h, uiState.linewidth);
  };

  window.initGUI = initGUI;

  onCanvasMousedown = function(e) {
    e.preventDefault();
    if (keyState.space) {
      uiState.canvasPanning = true;
      uiState.mouseXonPan = e.clientX;
      uiState.mouseYonPan = e.clientY;
      uiState.canvasXonPan = canvas.offset().left;
      uiState.canvasYonPan = canvas.offset().top;
      return;
    }
    uiState.newline = true;
    renderPoint(e);
    return uiState.canvasActive = true;
  };

  onDocumentMouseup = function(e) {
    uiState.canvasPanning = false;
    uiState.canvasActive = false;
    return uiState.newline = false;
  };

  onDocumentMousemove = function(e) {
    var pressure;

    if (uiState.canvasPanning) {
      canvas[0].style.left = (e.clientX - uiState.mouseXonPan + uiState.canvasXonPan) + "px";
      canvas[0].style.top = (e.clientY - uiState.mouseYonPan + uiState.canvasYonPan) + "px";
    }
    if (keyState.space && uiState.canvasPanning && !uiState.canvasCursorM) {
      canvas.css("cursor", "move");
      uiState.canvasCursorM = true;
    } else if (!uiState.canvasPanning && uiState.canvasCursorM) {
      canvas.css("cursor", "crosshair");
      uiState.canvasCursorM = false;
    }
    if (uiState.canvasActive) {
      if (DRAW_interval <= 0) {
        pressure = void 0;
        if (wacom) {
          pressure = wacom.pressure;
          uiState.linewidth = map(wacom.pressure, 0, 1, MAX_linewidth, MIN_linewidth);
          renderPoint(e);
        } else {
          renderPoint(e);
        }
        DRAW_interval = 1;
      }
      return DRAW_interval--;
    }
  };

  onDocumentKeydown = function(e) {
    switch (e.keyCode) {
      case 32:
        return keyState.space = true;
      case 16:
        return keyState.shift = true;
      case 17:
        return keyState.ctrl = true;
      case 83:
        if (keyState.ctrl && keyState.shift) {
          return saveDrawing();
        }
        break;
      case 8:
      case 46:
        if (keyState.ctrl) {
          sketch.dumpCache();
          return sketch.drawnP = 0;
        }
    }
  };

  onDocumentKeyup = function(e) {
    switch (e.keyCode) {
      case 32:
        return keyState.space = false;
      case 16:
        return keyState.shift = false;
      case 17:
        return keyState.ctrl = false;
    }
  };

}).call(this);
