// Generated by CoffeeScript 1.6.2
(function() {
  var AffineTransform, GlideTransform, IdentityTransform, Matrix2, PI, Point2d, ReflectionAbout, ReflectionTransform, RosetteGroup, RotationAbout, RotationTransform, ScalingAbout, ScalingTransform, TranslationTransform, abs, acos, affinesetproduct, asin, atan, cos, findclosure, floor, generateTiling, makegrid, max, min, multiRosette, multiRosette2, multiRosette3, planarSymmetries, pow, radialpoint, reflectRosette, root, rotateRosette, round, setproduct, sign, sin, sqrt, tan, uniqueaffineset, uniques;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  min = Math.min;

  max = Math.max;

  abs = Math.abs;

  sqrt = Math.sqrt;

  floor = Math.floor;

  round = Math.round;

  sin = Math.sin;

  cos = Math.cos;

  tan = Math.tan;

  acos = Math.acos;

  asin = Math.asin;

  atan = Math.atan;

  pow = Math.pow;

  PI = Math.PI;

  sign = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  Point2d = (function() {
    function Point2d(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    }

    Point2d.prototype.fromarray = function(ar) {
      return new Point2(ar[0], ar[1]);
    };

    Point2d.prototype.toarray = function() {
      return [x, y];
    };

    Point2d.prototype.plus = function(pIn) {
      var pOut;

      pOut = new Point2();
      pOut.x = this.x + pIn.x;
      pOut.y = this.y + pIn.y;
      return pOut;
    };

    Point2d.prototype._plus = function(pIn) {
      this.x = this.x + pIn.x;
      this.y = this.y + pIn.y;
      return this;
    };

    Point2d.prototype.minus = function(pIn) {
      var pOut;

      pOut = new Point2();
      pOut.x = this.x - pIn.x;
      pOut.y = this.y - pIn.y;
      return pOut;
    };

    Point2d.prototype._minus = function(pIn) {
      this.x = this.x - pIn.x;
      this.y = this.y - pIn.y;
      return this;
    };

    Point2d.prototype.times = function(a) {
      var pOut;

      pOut = new Point2();
      pOut.x = a * this.x;
      pOut.y = a * this.y;
      return pOut;
    };

    Point2d.prototype._times = function(pIn) {
      this.x = a * this.x;
      this.y = a * this.y;
      return this;
    };

    Point2d.prototype.dot = function(pIn) {
      return this.x * pIn.x + this.y * pIn.y;
    };

    Point2d.prototype.norm = function() {
      return sqrt(this.x * this.x + this.y * this.y);
    };

    Point2d.prototype.anglewith = function(pIn) {
      var pInnorm, thisnorm;

      thisnorm = sqrt(this.x * this.x + this.y * this.y);
      pInnorm = sqrt(pIn.x * pIn.x + pIn.y * pIn.y);
      return acos((this.x * pIn.x + this.y * pIn.y) / thisnorm / pInnorm);
    };

    Point2d.prototype.cross = function(pIn) {
      return this.x * pIn.y - this.y * pIn.x;
    };

    return Point2d;

  })();

  radialpoint = function(r, theta) {
    return new Point2d(r * cos(theta), r * sin(theta));
  };

  Matrix2 = (function() {
    var fromarray;

    function Matrix2(a, b, c, d) {
      this.a = a || 1;
      this.b = b || 0;
      this.c = c || 0;
      this.d = d || 1;
    }

    fromarray = function(ar) {
      return new Matrix2(ar[0][0], ar[0][1], ar[1][0], ar[1][1]);
    };

    Matrix2.prototype.add = function(matIn) {
      var matOut;

      matOut = new Matrix2();
      matOut.a = this.a + matIn.a;
      matOut.b = this.a + matIn.b;
      matOut.c = this.a + matIn.c;
      matOut.d = this.a + matIn.d;
      return matOut;
    };

    Matrix2.prototype.multiply = function(matIn) {
      var matOut;

      matOut = new Matrix2();
      matOut.a = this.a * matIn.a + this.b * matIn.c;
      matOut.b = this.a * matIn.b + this.b * matIn.d;
      matOut.c = this.c * matIn.a + this.d * matIn.c;
      matOut.d = this.c * matIn.b + this.d * matIn.d;
      return matOut;
    };

    Matrix2.prototype.inverse = function() {
      var det, matOut;

      matOut = new Matrix2();
      det = this.a * this.d - this.b * this.c;
      matOut.a = this.d / det;
      matOut.b = -1 * this.b / det;
      matOut.c = -1 * this.c / det;
      matOut.d = this.a / det;
      return matOut;
    };

    return Matrix2;

  })();

  AffineTransform = (function() {
    function AffineTransform(a, b, c, d, x, y) {
      this.a = a || 1;
      this.b = b || 0;
      this.c = c || 0;
      this.d = d || 1;
      this.x = x || 0;
      this.y = y || 0;
    }

    AffineTransform.prototype.multiply = function(Afin) {
      var Afout;

      Afout = new AffineTransform();
      Afout.a = this.a * Afin.a + this.b * Afin.c;
      Afout.b = this.a * Afin.b + this.b * Afin.d;
      Afout.c = this.c * Afin.a + this.d * Afin.c;
      Afout.d = this.c * Afin.b + this.d * Afin.d;
      Afout.x = this.x + this.a * Afin.x + this.b * Afin.y;
      Afout.y = this.y + this.c * Afin.x + this.d * Afin.y;
      return Afout;
    };

    AffineTransform.prototype.Lmultiply = function(Afin) {
      var Afout;

      Afout = new AffineTransform();
      Afout.a = Afin.a * this.a + Afin.b * this.c;
      Afout.b = Afin.a * this.b + Afin.b * this.d;
      Afout.c = Afin.c * this.a + Afin.d * this.c;
      Afout.d = Afin.c * this.b + Afin.d * this.d;
      Afout.x = Afin.x + Afin.a * this.x + Afin.b * this.y;
      Afout.y = Afin.y + Afin.c * this.x + Afin.d * this.y;
      return Afout;
    };

    AffineTransform.prototype.inverse = function() {
      var Afout, det;

      Afout = new AffineTransform();
      det = this.a * this.d - this.b * this.c;
      Afout.a = this.d / det;
      Afout.b = -1 * this.b / det;
      Afout.c = -1 * this.c / det;
      Afout.d = this.a / det;
      Afout.x = (-1 * this.d + this.x + this.b * this.y) / det;
      Afout.y = (-1 * this.a + this.y + this.c * this.x) / det;
      return Afout;
    };

    AffineTransform.prototype.on = function(x, y) {
      var nx, ny;

      nx = this.a * x + this.b * y + this.x;
      ny = this.c * x + this.d * y + this.y;
      return [nx, ny];
    };

    AffineTransform.prototype.tolist = function() {
      return [this.a, this.b, this.c, this.d, this.x, this.y];
    };

    AffineTransform.prototype.sameas = function(Afin, tol) {
      var sum;

      tol = tol || 1e-8;
      sum = 0;
      sum += abs(this.a - Afin.a);
      sum += abs(this.b - Afin.b);
      sum += abs(this.c - Afin.c);
      sum += abs(this.d - Afin.d);
      sum += abs(this.x - Afin.x);
      sum += abs(this.y - Afin.y);
      if (sum < tol) {
        return true;
      } else {
        return false;
      }
    };

    return AffineTransform;

  })();

  IdentityTransform = function() {
    return new AffineTransform(1, 0, 0, 1, 0, 0);
  };

  ScalingTransform = function(scale, scaley) {
    scaley = scaley || scale;
    return new AffineTransform(scale, 0, 0, scaley, 0, 0);
  };

  RotationTransform = function(angle) {
    return new AffineTransform(Math.cos(angle), Math.sin(angle), -1 * Math.sin(angle), Math.cos(angle), 0, 0);
  };

  TranslationTransform = function(dx, dy) {
    return new AffineTransform(1, 0, 0, 1, dx, dy);
  };

  ReflectionTransform = function(angle) {
    return new AffineTransform(Math.cos(2 * angle), Math.sin(2 * angle), Math.sin(2 * angle), -1 * Math.cos(2 * angle), 0, 0);
  };

  ScalingAbout = function(scale, px, py) {
    return TranslationTransform(px, py).multiply(ScalingTransform(scale)).multiply(TranslationTransform(-px, -py));
  };

  RotationAbout = function(angle, px, py) {
    return TranslationTransform(px, py).multiply(RotationTransform(angle)).multiply(TranslationTransform(-px, -py));
  };

  ReflectionAbout = function(angle, px, py) {
    return TranslationTransform(px, py).multiply(ReflectionTransform(angle)).multiply(TranslationTransform(-px, -py));
  };

  GlideTransform = function(angle, distance, px, py) {
    return ReflectionAbout(angle, px, py).multiply(TranslationTransform(distance * cos(angle), distance * sin(angle)));
  };

  setproduct = function(X, Y, prodfunc) {
    prodfunc = prodfunc || function(x, y) {
      return [x, y];
    };
    return _.reduce(X, (function(memo, x) {
      return _.map(Y, function(y) {
        return prodfunc(x, y);
      }).concat(memo);
    }), []);
  };

  affinesetproduct = function(Afset1, Afset2) {
    return setproduct(Afset1, Afset2, function(x, y) {
      return x.multiply(y);
    });
  };

  uniques = function(ar, eqfunc) {
    var i, j, len, newar, sameQ;

    eqfunc = eqfunc || (function(x, y) {
      return x === y;
    });
    i = 0;
    j = 0;
    len = ar.length;
    sameQ = false;
    newar = [];
    i = 0;
    while (i < len) {
      sameQ = false;
      j = i + 1;
      while (j < len) {
        if (eqfunc(ar[i], ar[j])) {
          sameQ = true;
          break;
        } else {

        }
        j += 1;
      }
      if (!sameQ) {
        newar.push(ar[i]);
      }
      i += 1;
    }
    return newar;
  };

  uniqueaffineset = function(Afset) {
    return uniques(Afset, function(x, y) {
      return x.sameas(y);
    });
  };

  findclosure = function(Afset, recursion_limit) {
    var i, oldset, setprod, uniqueset;

    recursion_limit = recursion_limit || 3;
    oldset = Afset;
    i = 0;
    while (i < recursion_limit) {
      setprod = affinesetproduct(Afset, Afset).concat(Afset);
      uniqueset = uniqueaffineset(setprod);
      if (oldset === uniqueset) {
        break;
      }
      Afset = uniqueset;
      oldset = uniqueset;
      i++;
    }
    console.log("/uniqueset() length: " + uniqueset.length);
    return uniqueset;
  };

  makegrid = function(nx, ny, d) {
    var Afs, i, j, _i, _j, _ref, _ref1;

    Afs = [];
    for (i = _i = 0, _ref = nx - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = ny - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        Afs.push(TranslationTransform(i * d, j * d));
      }
    }
    return Afs;
  };

  rotateRosette = function(n, x, y) {
    var Afs, i, _i, _ref;

    Afs = [];
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      Afs.push(RotationAbout(i * 2 * PI / n, x, y));
    }
    return Afs;
  };

  reflectRosette = function(n, x, y, offsetangle) {
    var Afs, i, _i, _ref;

    offsetangle = offsetangle || 0;
    Afs = [];
    Afs.push(IdentityTransform());
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      Afs.push(RotationAbout(offsetangle, x, y).multiply(ReflectionAbout(i * PI / n, x, y)));
    }
    return findclosure(Afs);
  };

  RosetteGroup = function(n1, n2, x, y, offsetangle) {
    var Af1, Af2;

    offsetangle = offsetangle || 0;
    Af1 = rotateRosette(n1, x, y);
    Af2 = reflectRosette(n2, x, y);
    return findclosure(Af1.concat(affinesetproduct([RotationAbout(offsetangle, x, y)], Af2)));
  };

  multiRosette = function(n1, n2, x1, y1, x2, y2) {
    var Af1, Af2;

    Af1 = rotateRosette(n1, x1, y1);
    Af2 = reflectRosette(n2, x2, y2);
    return affinesetproduct(Af1, Af2);
  };

  multiRosette2 = function(n1, n2, x1, y1, x2, y2) {
    var Af1, Af2;

    Af1 = rotateRosette(n1, x1, y1);
    Af2 = reflectRosette(n2, x2, y2);
    return affinesetproduct(Af2, Af1);
  };

  multiRosette3 = function(n1, n2, n3, a, d, skew, x, y) {
    var Af1, afop, afset, i, j, _i, _j, _ref, _ref1;

    Af1 = rotateRosette(n1, x, y);
    afset = [];
    for (i = _i = 0, _ref = n2 - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 1, _ref1 = n3 - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
        afop = RotationAbout(j * PI * skew, x, y).multiply(TranslationTransform(j * d * cos(i * 2 * PI / n2), j * d * sin(i * 2 * PI / n2)).multiply(RotationAbout(i * 2 * PI / n2, x, y).multiply(ScalingAbout(pow(a, j), x, y))));
        afset = afset.concat(affinesetproduct([afop], Af1));
      }
    }
    return afset;
  };

  generateTiling = function(spec, nx, ny, d, x, y) {
    var Afset, glideset, i, j, refs, refset, rots, rotset, transset, vec0, vec1, _i, _j, _ref, _ref1, _ref2, _ref3;

    rotset = [];
    refset = [];
    glideset = [];
    Afset = [];
    transset = [];
    rots = spec.rots;
    refs = spec.refs;
    vec0 = spec.vec0;
    vec1 = spec.vec1;
    rotset.push(IdentityTransform());
    if (spec.rots) {
      _.each(rots, function(r) {
        return rotset.push(RotationAbout(r[0], x + d * r[1], y + d * r[2]));
      });
      if (spec.closerot && spec.closerot === true) {
        rotset = findclosure(rotset);
      }
    }
    if (spec.refs) {
      _.each(refs, function(r) {
        return refset.push(ReflectionAbout(r[0], x + d * r[1], y + d * r[2]));
      });
      if (spec.closeref && spec.closeref === true) {
        refset = findclosure(refset);
      }
    }
    if (spec.refrot && spec.refrot === true) {
      Afset = uniqueaffineset(affinesetproduct(rotset, refset).concat(rotset));
    } else {
      Afset = uniqueaffineset(rotset.concat(refset));
    }
    if (spec.glides) {
      _.each(spec.glides, function(r) {
        return glideset.push(GlideTransform(r[0], d * r[1], x + d * r[2], y + d * r[3]));
      });
    }
    Afset = Afset.concat(glideset);
    for (i = _i = _ref = -floor(nx / 2), _ref1 = nx / 2; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
      for (j = _j = _ref2 = -floor(ny / 2), _ref3 = ny / 2; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
        transset.push(TranslationTransform((i * vec0[0] + j * vec1[0]) * d, (i * vec0[1] + j * vec1[1]) * d));
      }
    }
    return affinesetproduct(transset, Afset);
  };

  planarSymmetries = {
    squaregrid: {
      rots: [],
      refs: [],
      vec0: [0, 1],
      vec1: [1, 0]
    },
    diagonalgrid: {
      rots: [],
      refs: [],
      vec0: [0.707107, 0.707107],
      vec1: [0.707107, -0.707107]
    },
    hexgrid: {
      rots: [],
      refs: [],
      vec0: [0.866025, 1.5],
      vec1: [1.73205, 0.0]
    },
    p1: {
      rots: [],
      refs: [],
      vec0: [0.866025, 1.5],
      vec1: [1.73205, 0.0]
    },
    pm: {
      rots: [],
      refs: [[PI / 2, 0, 0], [PI / 2, 0, -1 / 2]],
      vec0: [0, 1],
      vec1: [1, 0]
    },
    cm: {
      rots: [],
      refs: [[PI / 2, 0, 0]],
      vec0: [sin(PI / 4), cos(PI / 4)],
      vec1: [-sin(PI / 4), cos(PI / 4)]
    },
    pg: {
      rots: [],
      refs: [],
      glides: [[PI / 2, 0.866025, 0.0, 0.0]],
      vec0: [0, 2],
      vec1: [1, 0]
    },
    pmg: {
      rots: [[PI, 1.0, 0.25]],
      refs: [[0.0, 0.0, 0.0]],
      glides: [[PI / 2, .5, 1.0, 0.0]],
      vec0: [2, 0],
      vec1: [0, 1]
    },
    pgg: {
      rots: [[PI, 0.0, 0.0]],
      refs: [],
      glides: [[0.0, 1.0, 0.0, 0.25], [PI / 2, .5, .5, 0.0]],
      vec0: [2, 0],
      vec1: [0, 1]
    },
    pmm: {
      rots: [[PI, 0, 0]],
      refs: [[0, 0, 0], [PI / 2, 0, 0]],
      vec0: [0, 1],
      vec1: [1, 0]
    },
    p2: {
      rots: [[PI, 0, 0]],
      refs: [],
      vec0: [0.866025, 1.5],
      vec1: [1.73205, 0.0]
    },
    cmm: {
      rots: [[PI, 0, 0]],
      refs: [[PI / 2, 0, 0], [0, 0, 0]],
      vec0: [sin(PI / 4), cos(PI / 4)],
      vec1: [-sin(PI / 4), cos(PI / 4)]
    },
    p4: {
      rots: [[PI / 2, 0, 0], [PI, 0, 0], [3 * PI / 2, 0, 0]],
      refs: [],
      vec0: [1, 0],
      vec1: [0, 1]
    },
    p4g: {
      rots: [[PI / 2, 0, 0], [PI, 0, 0], [3 * PI / 2, 0, 0]],
      refs: [[-PI / 4, .5, 0.0]],
      refrot: true,
      vec0: [1, 0],
      vec1: [0, 1]
    },
    p4m: {
      rots: [[PI / 2, 0, 0], [PI, 0, 0], [3 * PI / 2, 0, 0]],
      refs: [[-PI / 4, 0.0, 0.0], [PI / 4, 0.0, 0.0], [0.0, 0.0, 0.0]],
      closeref: true,
      vec0: [1, 0],
      vec1: [0, 1]
    },
    p3: {
      rots: [[2 * PI / 3, 0.866017, -0.5], [4 * PI / 3, 0.866017, -0.5]],
      refs: [],
      vec0: [0.866025, -1.5],
      vec1: [1.73205, 0.0]
    },
    p6: {
      rots: [[2 * PI / 3, 0.866017, -0.5], [4 * PI / 3, 0.866017, -0.5], [PI / 3.0, 0.0, 0.0], [-PI / 3.0, 0.0, 0.0], [3 * PI / 3.0, 0.0, 0.0]],
      refs: [],
      vec0: [0.866025, -1.5],
      vec1: [1.73205, 0.0]
    },
    p31m: {
      rots: [[2 * PI / 3, 0.866017, -0.5], [4 * PI / 3, 0.866017, -0.5]],
      refs: [[PI / 3, 0.0, 0.0], [-PI / 3, 0.0, 0.0], [0.0, 0.0, 0.0]],
      vec0: [0.866025, -1.5],
      vec1: [1.73205, 0.0]
    },
    p3m1: {
      rots: [[2 * PI / 3, 0, 0], [4 * PI / 3, 0, 0]],
      refs: [[-PI / 2, 0, 0], [-2 * PI / 3 - PI / 2, 0, 0], [2 * PI / 3 - PI / 2, 0, 0]],
      vec0: [0.866025, 1.5],
      vec1: [1.73205, 0.0]
    },
    p6m: {
      rots: [],
      refs: [[PI / 6, 0, 0], [2 * PI / 6, 0, 0], [3 * PI / 6, 0, 0], [4 * PI / 6, 0, 0], [5 * PI / 6, 0, 0], [6 * PI / 6, 0, 0]],
      closeref: true,
      vec0: [0.866025, 1.5],
      vec1: [1.73205, 0.0]
    }
  };

  root.rotateRosette = rotateRosette;

  root.reflectRosette = reflectRosette;

  root.RosetteGroup = RosetteGroup;

  root.multiRosette = multiRosette;

  root.multiRosette2 = multiRosette2;

  root.multiRosette3 = multiRosette3;

  root.generateTiling = generateTiling;

  root.planarSymmetries = planarSymmetries;

  root.TranslationTransform = TranslationTransform;

  root.IdentityTransform = IdentityTransform;

  root.GlideTransform = GlideTransform;

  root.ReflectionTransform = ReflectionTransform;

  root.RotationTransform = RotationTransform;

  root.ScalingTransform = ScalingTransform;

  root.RotationAbout = RotationAbout;

  root.affinesetproduct = affinesetproduct;

}).call(this);
